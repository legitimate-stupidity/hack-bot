"""
Agent definitions for the autonomous coding system.
"""
from llm import llm
from tools import TOOLBOX, ToolResult
import ui
import textwrap
from typing import Dict, Any

class PlannerAgent:
    """Generates structured plans for task completion."""
    
    async def generate_plan(self, prompt: str, context: str) -> Dict[str, Any]:
        """Generate a plan based on user request and context."""
        
        # Build system prompt
        system_prompt = f"""You are the PlannerAgent. You generate detailed, structured plans for task execution.

Available tools: {', '.join(TOOLBOX.keys())}

User Request: {prompt}

Current Context:
{context}

Format your response as JSON with this exact structure:
{{
    "thought": "Your reasoning about how to approach this task",
    "steps": [
        {{
            "tool": "tool_name",
            "args": {{"arg1": "value1", "arg2": "value2"}},
            "is_verification": false
        }}
    ]
}}

Important:
- Each step should use ONE tool call
- The 'is_verification' flag marks final testing steps
- Be specific with arguments (file paths, commands, etc.)
- Include error handling and testing steps
"""
        
        plan = await llm.generate_json(system_prompt)
        
        if 'thought' in plan:
            ui.print_agent_thought("PlannerAgent", plan['thought'])
        
        return plan

class EditorAgent:
    """Executes tool calls generated by the planner."""
    
    async def execute_step(self, step: Dict[str, Any]) -> ToolResult:
        """Execute a single step from the plan."""
        tool_name = step.get("tool")
        tool_args = step.get("args", {})

        if tool_name not in TOOLBOX:
            return ToolResult(success=False, stderr=f"Unknown tool: {tool_name}")
        
        # Get the tool function
        tool_function = TOOLBOX[tool_name]
        
        # Execute the tool
        try:
            result = await tool_function(**tool_args)
            return result
        except TypeError as e:
            return ToolResult(success=False, stderr=f"Invalid arguments for {tool_name}: {str(e)}")
        except Exception as e:
            return ToolResult(success=False, stderr=f"Tool execution error: {str(e)}")

class VerifierAgent:
    """Verifies task completion and identifies issues."""
    
    def should_fix(self, result: ToolResult, step: Dict[str, Any]) -> tuple[bool, str]:
        """
        Determine if a step failure needs fixing.
        Returns (needs_fix, error_message)
        """
        if result.success:
            return False, ""
        
        is_verification = step.get("is_verification", False)
        
        # Always fix verification failures
        if is_verification:
            return True, result.stderr
        
        # For other tools, only fix if there's an error
        if result.return_code and result.return_code != 0:
            return True, result.stderr
        
        return result.stderr != "", result.stderr

    async def analyze_failure(self, error: str, context: str) -> str:
        """Generate a failure analysis prompt for the planner."""
        return f"""The previous step failed with this error:

```
{error}
```

Context:
{context}

Please analyze the error and generate a new plan to fix the issue and complete the task."""
